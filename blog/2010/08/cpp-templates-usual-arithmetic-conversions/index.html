<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>C++ Templates and Usual Arithmetic Conversions</title>
  <link rel="alternate" href="http://feeds.feedburner.com/janmr-blog" title="janmr blog" type="application/rss+xml">
  <link rel="stylesheet" href="/css/main.7614535f90467929.css">
</head>
<body>
  <div id="wrapper">
    <h1><a href="/blog/">janmr blog</a></h1>
    <div class="content">
      <div class="main">        <h2>C++ Templates and Usual Arithmetic Conversions<br><small><time datetime="2010-08-28">28 August 2010</time></small></h2>
        <div class="post-tags">
          <a class="label" href="/blog/tags/cpp">cpp</a> <a class="label" href="/blog/tags/templates">templates</a> <a class="label" href="/blog/tags/data-types">data-types</a> 
        </div>
        <div class="post-body">
          <p>If you add a <code>short int</code> and a <code>char</code> in C++, what is the resulting type? What if you subtract a <code>long int</code> from an <code>unsigned int</code>? The answers actually depend on the compiler and the target architecture (<code>int</code> or <code>unsigned</code> in the first case and <code>long int</code> or <code>unsigned long int</code> in the second). This article lists the rules from the current C++ standard and gives an example of how the type can be resolved at compile time using templates.</p>
<p><span></span></p>
<h3>Introduction</h3>
<div class="pull-right"><a href="http://www.amazon.com/gp/product/0201700735?ie=UTF8&tag=sputsoft-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201700735"><img src="/media/books/stroustrup.jpg" alt=""></a></div>
<p>Let me first note that I will be referring to the current C++ standard from 1998 (with a minor revision in 2003). This standard is described in <a href="http://www.amazon.com/gp/product/0201700735?ie=UTF8&tag=sputsoft-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201700735">The C++ Programming Language</a> by <a href="http://www.stroustrup.com">Bjarne Stroustrup</a>. It can also be found <a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2/">online</a>.</p>
<p>In C++, the <em>integer types</em> are <code>short int</code>, <code>int</code>, <code>long int</code> and the unsigned versions of these. The integer types together with the boolean type (<code>bool</code>) and the character types (plain/<code>signed</code>/<code>unsigned</code> <code>char</code> and <code>wchar_t</code>) are called <em>integral types</em>. The integral types together with the floating-point types (<code>float</code>, <code>double</code>, and <code>long double</code>) are called <em>arithmetic types</em>.</p>
<h3>Resolving the Return Type</h3>
<p>Consider having the function <code>fct</code> overloaded with one function for each arithmetic type, for example:</p>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(<span class="hljs-keyword">short</span> v)</span>          </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; &quot;<span class="hljs-keyword">short</span> &quot;          &lt;&lt; v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; &quot;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> &quot; &lt;&lt; v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span>            </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; &quot;<span class="hljs-keyword">int</span> &quot;            &lt;&lt; v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fct</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> v)</span>       </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; &quot;<span class="hljs-keyword">unsigned</span> &quot;       &lt;&lt; v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; }
...
</code></pre>
<p>and so on. If you now have the following little routine:</p>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> b)</span> </span>{
  fct(a + b);
}
</code></pre>
<p>which instance of <code>fct</code> is called? This is another way of asking the question that started this article.</p>
<p>When a binary operator (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) is applied to operands with arithmetic types, the C++ compiler must do the following:</p>
<ul>
<li><strong>Integral promotion</strong>. Each operand is, if necessary, promoted to at least an <code>int</code> (to be made more precise below).</li>
<li><strong>Usual arithmetic conversions</strong>. Based on the (possibly promoted) types of the operands, a common type is found. Both operands are converted to this type, which will also be the resulting type.</li>
</ul>
<h3>Integral Promotions</h3>
<p>Integral promotions are defined in Section 4.5, page 4-3, from the <a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2/">online standard</a> and in Section C.6.1, page 833, from <a href="http://www.amazon.com/gp/product/0201700735?ie=UTF8&tag=sputsoft-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201700735">The C++ Programming Language</a>. If we ignore enumerations and bit-fields, they can be summed up as follows:</p>
<ul>
<li>A <code>char</code>, <code>signed char</code>, <code>signed char</code>, <code>short int</code>, <code>unsigned short int</code> is converted to <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, it is converted to an <code>unsigned int</code>.</li>
<li><code>wchar_t</code> is converted to the first of the following types that can represent all the values of <code>wchar_t</code>: <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>.</li>
<li><code>bool</code> is converted to <code>int</code>.</li>
</ul>
<h3>Usual Arithmetic Conversions</h3>
<p>The rules for usual arithmetic conversions can be found in Section 5, page 5-2, from the <a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2/">online standard</a> and in Section C.6.3, page 836, from <a href="http://www.amazon.com/gp/product/0201700735?ie=UTF8&tag=sputsoft-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201700735">The C++ Programming Language</a>. Assuming integral promotions have been performed (if needed), the usual arithmetic conversions are in essense the following:</p>
<ul>
<li>If one operand is a <code>long int</code> and the other <code>unsigned int</code>, then if a <code>long int</code> can represent all the values of an <code>unsigned int</code>, the <code>unsigned int</code> shall be converted to a <code>long int</code>; otherwise both operands shall be converted to <code>unsigned long int</code>.</li>
<li>Otherwise, find the highest ranking type among the operands and convert the other operand to this type. The relevant types listed from high to low rank are: <code>long double</code>, <code>double</code>, <code>float</code>, <code>unsigned long</code>, <code>long</code>, <code>unsigned</code>, <code>int</code>.</li>
</ul>
<h3>Using Templates To Get The Type</h3>
<p>Those were the rules in written form. Imagine now that we have, e.g., the following routine:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;
[some-type] add(<span class="hljs-keyword">const</span> A&amp; a, <span class="hljs-keyword">const</span> B&amp; b) { <span class="hljs-keyword">return</span> a + b; }
</code></pre>
<p>We would like the types of <code>add(a, b)</code> and <code>a + b</code> to be identical when both <code>a</code> and <code>b</code> are arithmetic types.</p>
<p>First, promotions. By default, a type is not promoted:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span> {</span> <span class="hljs-keyword">typedef</span> T type; };
</code></pre>
<p>We then use template specializations for the types that need to be promoted. Some of these are easy:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">signed</span> <span class="hljs-keyword">short</span>&gt; { <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> type; };
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">bool</span>&gt; { <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> type; };
</code></pre>
<p>For the rest, we need a sort of if-then-else for choosing a type:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">bool</span> C, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">choose_type</span> {</span> <span class="hljs-keyword">typedef</span> F type; };
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">choose_type</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-literal">true</span>, T, F&gt; { <span class="hljs-keyword">typedef</span> T type; };
</code></pre>
<p>So the boolean value of the first argument determines whether to choose the type <code>T</code> (if true) or <code>F</code> (if false). We now have:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span>&gt; {
  <span class="hljs-keyword">typedef</span> choose_type&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">short</span>) &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span>&gt;::type type;
};
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span>&gt; {
  <span class="hljs-keyword">typedef</span> choose_type&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) &lt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span>&gt;::type type;
};
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt; {
  <span class="hljs-keyword">typedef</span> choose_type&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span>&gt;::type type;
};
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">char</span>&gt;
 : <span class="hljs-keyword">public</span> promote&lt;choose_type&lt;<span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">char</span>&gt;::is_signed,
                              <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>&gt;::type&gt; {};
</code></pre>
<p>This last one for plain <code>char</code> is needed because C++ considers <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> to be three distinct types. The standard does not specify whether <code>char</code> is signed or not. (The <code>numeric_limits</code> template is defined in the <code>limits</code> header.)</p>
<p>Finally, to promote <code>wchar_t</code>:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">promote</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">wchar_t</span>&gt; {
  <span class="hljs-keyword">typedef</span> choose_type&lt;
            <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">wchar_t</span>&gt;::is_signed,
            choose_type&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) &lt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>&gt;::type,
            choose_type&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">wchar_t</span>) &lt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">unsigned</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>&gt;::type
          &gt;::type type;
};
</code></pre>
<p>We can now turn to the usual arithmetic conversions. First, we promote each type, if necessary:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resolve_uac</span> :</span> <span class="hljs-keyword">public</span> resolve_uac2&lt;<span class="hljs-keyword">typename</span> promote&lt;A&gt;::type,
                                         <span class="hljs-keyword">typename</span> promote&lt;B&gt;::type&gt; {};
</code></pre>
<p>This ensures that the type arguments for <code>resolve_uac2</code> are at least <code>int</code>s. We then introduce ranks for those types:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>;</span>
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">int</span>&gt;           { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">1</span>; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">unsigned</span>&gt;      { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">2</span>; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">long</span>&gt;          { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">3</span>; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>&gt; { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">4</span>; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">float</span>&gt;         { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">5</span>; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">double</span>&gt;        { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">6</span>; };
<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_rank</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt;   { <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rank = <span class="hljs-number">7</span>; };
</code></pre>
<p>Now we can pick the type with the highest rank:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resolve_uac2</span> {</span>
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> choose_type&lt;
            type_rank&lt;A&gt;::rank &gt;= type_rank&lt;B&gt;::rank, A, B
          &gt;::type return_type;
};
</code></pre>
<p>Finally we need to deal with the special case where one type is <code>long int</code> and the other is <code>unsigned int</code>:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resolve_uac2</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">long</span>, <span class="hljs-keyword">unsigned</span>&gt; {
  <span class="hljs-keyword">typedef</span> choose_type&lt;<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>),
                      <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">long</span>&gt;::type return_type;
};
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resolve_uac2</span>&<span class="hljs-title">lt</span>;</span><span class="hljs-keyword">unsigned</span>, <span class="hljs-keyword">long</span>&gt; : <span class="hljs-keyword">public</span> resolve_uac2&lt;<span class="hljs-keyword">long</span>, <span class="hljs-keyword">unsigned</span>&gt; {};
</code></pre>
<p>We can now write the <code>add</code> routine from earlier as:</p>
<pre><code class="language-cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;
<span class="hljs-keyword">typename</span> resolve_uac&lt;A, B&gt;::<span class="hljs-function">return_type <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> A&amp; a, <span class="hljs-keyword">const</span> B&amp; b)</span>
</span>{ <span class="hljs-keyword">return</span> a + b; }
</code></pre>
<p>and the return type will match that of the <code>+</code> operation. Note that the arguments to <code>add</code> have to be arithmetic types (because of the <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution-failure-is-not-an-error</a> principle).</p>
<h3>Remarks</h3>
<p>The rules and implementation above should be complete with the exception of enumerations and bit-fields, see the links to the standard for the missing pieces. Note also that the rules for promotions and usual arithmetic conversions will change (slightly) in the upcoming C++0x standard, see the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">C++0x draft</a>, Section 5, page 84.</p>

        </div>
        <div class="page-navigation">
          <div class="prev-post">
            <a href="/blog/2010/07/bitwise-operators-and-negative-numbers" title="Previous post: Bitwise Operators and Negative Numbers">&laquo; Bitwise Operators and Negative Numbers</a>
          </div>
          <div class="next-post">
            <a href="/blog/2010/09/computing-the-integer-binary-logarithm" title="Next post: Computing the Integer Binary Logarithm">Computing the Integer Binary Logarithm &raquo;</a>
          </div>
        </div>
        <div id="disqus_thread"></div>
      </div>
      <div class="sidebar">
        <h4>About</h4>
        <p>A blog about mathematics and computer programming by
          <a href="/">Jan Marthedal Rasmussen</a>.</p>
        <h4>Links</h4>
        <p><span class="icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
            <circle cx="2" cy="4" r="2"></circle><circle cx="2" cy="12" r="2"></circle><circle cx="2" cy="20" r="2"></circle><circle cx="2" cy="28" r="2"></circle>
            <rect x="8" y="2" width="24" height="4"></rect><rect x="8" y="10" width="24" height="4"></rect><rect x="8" y="18" width="24" height="4"></rect><rect x="8" y="26" width="24" height="4"></rect>
          </svg>
        </span>
        <a href="/blog/">All posts</a></p>
        <p><span class="icon">
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414">
            <path d="M16 3.038c-.59.26-1.22.437-1.885.517.677-.407 1.198-1.05 1.443-1.816-.634.37-1.337.64-2.085.79-.598-.64-1.45-1.04-2.396-1.04-1.812 0-3.282 1.47-3.282 3.28 0 .26.03.51.085.75-2.728-.13-5.147-1.44-6.766-3.42C.83 2.58.67 3.14.67 3.75c0 1.14.58 2.143 1.46 2.732-.538-.017-1.045-.165-1.487-.41v.04c0 1.59 1.13 2.918 2.633 3.22-.276.074-.566.114-.865.114-.21 0-.41-.02-.61-.058.42 1.304 1.63 2.253 3.07 2.28-1.12.88-2.54 1.404-4.07 1.404-.26 0-.52-.015-.78-.045 1.46.93 3.18 1.474 5.04 1.474 6.04 0 9.34-5 9.34-9.33 0-.14 0-.28-.01-.42.64-.46 1.2-1.04 1.64-1.7z" fill-rule="nonzero"/>
          </svg></span>
          <a href="https://twitter.com/janmarthedal">Twitter profile</a></p>
        <p><span class="icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414">
            <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
          </svg></span>
          <a href="https://github.com/janmarthedal/">GitHub profile</a></p>
        <p><span class="icon">
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414">
            <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194 11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0 13.806c0-1.21.983-2.195 2.194-2.195zM10.606 16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"/>
          </svg></span>
          <a href="http://feeds.feedburner.com/janmr-blog">Subscribe in a reader</a></p>
        <footer><p class="text-muted">Copyright Jan Marthedal Rasmussen © 2019</p></footer>
      </div>
    </div>
  </div>
  <script src="/js/main.9d716cf03cf8bdc8.js" defer></script>
  <script src="https://www.google-analytics.com/analytics.js" defer></script>
</body>
</html>
