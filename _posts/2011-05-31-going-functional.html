---
layout: wppost
title: Going Functional
author: Jan Marthedal Rasmussen
excerpt: ! "<a href=\"http://en.wikipedia.org/wiki/Imperative_programming\">Imperative
  programming</a> languages&mdash;such as C++, Java, Perl and assembly&mdash;are
  by far the <a href=\"http://www.langpop.com\">most common</a>. They
  all lie fairly close to the underlying computer architecture by executing one statement
  at a time, changing a state along the way. They describe <i>how</i> to compute
  something.\r\n\r\nPurely functional languages&mdash;such as <a href=\"http://www.erlang.org/\">Erlang</a>
  and <a href=\"http://www.haskell.org\">Haskell</a>&mdash;have no state,
  only values, expressions and functions. All variables are <a href=\"http://en.wikipedia.org/wiki/Mutable\">immutable</a>,
  that is, when a value has been assigned to a variable, it can never change. Purely
  functional programming languages describe <i>what</i> to compute, but not explicitly
  how.\r\n\r\n"
date: 2011-05-31 13:55:51.000000000 +02:00
categories:
- programming
tags:
- functional programming
- erlang
- lisp
- ml
---
<p><a href="http://en.wikipedia.org/wiki/Imperative_programming">Imperative programming</a> languages&mdash;such as C++, Java, Perl and assembly&mdash;are by far the <a href="http://www.langpop.com">most common</a>. They all lie fairly close to the underlying computer architecture by executing one statement at a time, changing a state along the way. They describe <i>how</i> to compute something.</p>
<p>Purely functional languages&mdash;such as <a href="http://www.erlang.org/">Erlang</a> and <a href="http://www.haskell.org">Haskell</a>&mdash;have no state, only values, expressions and functions. All variables are <a href="http://en.wikipedia.org/wiki/Mutable">immutable</a>, that is, when a value has been assigned to a variable, it can never change. Purely functional programming languages describe <i>what</i> to compute, but not explicitly how.</p>
<span></span>
<p>Non-pure <a href="http://en.wikipedia.org/wiki/Functional_programming">functional programming</a> languages have features from both imperative and purely functional languages. A typical feature of functional programming languages, pure or not, is that functions are often considered values in their own right. This leads to <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a> which basically are functions that operate on other functions. Actually, <a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a> is considered a functional programming language <a href="http://www.blinkx.com/watch-video/douglas-crockford-on-functional-javascript/xscZz8XhfuNQ_aaVuyUB2A">by some</a> because of its ability to treat functions as values.</p>
<div style="float:right">
  <a href="{% amazon paulson %}"><img src="{% bookcover paulson %}" /></a>
</div>
<p>I find functional programming languages very interesting. First of all, pure functional programming languages have a certain, well, purity to them. Secondly, they force you to think differently about programming, and this can be a healthy thing. Let me introduce three of the functional programming languages that I have come across.</p>
<p>The first functional programming language I ever encountered was <a href="http://en.wikipedia.org/wiki/Standard_ML">Standard ML</a> (actually, we used a light-weight implementation called <a href="http://www.itu.dk/~sestoft/mosml.html">Moscow ML</a>). It enables assignments and is thus not pure. It features, among other things, type inference which is very nice. For instance, an exponentation function <span class="sputcode">power</span> could have the type</p>
<pre class="sputcode">
val power = fn : real * int -> real
</pre>
<p>Similarly, a <span class="sputcode">map</span> function which applies a user-supplied function to each element of a list could get the type</p>
<pre class="sputcode">
val map = fn : ('a -> 'b) -> 'a list -> 'b list
</pre>
<div style="float:right">
  <a href="{% amazon erlang %}"><img src="{% bookcover erlang %}" /></a>
</div>
<p>This means that <span class="sputcode">map</span> takes as input a function (mapping an element of type <span class="sputcode">a&#8217;</span> to an element of type <span class="sputcode">b&#8217;</span>) and outputs a new function. This output function can then convert a list of type <span class="sputcode">a&#8217;</span> elements to a list of type <span class="sputcode">b&#8217;</span> elements. This is powerful stuff.</p>
<p>Erlang is a pure functional programming language. It is often praised for being well-suited for large-scale, distributed and fault-tolerant applications. For instance, the very cool <a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL</a> database system <a href="http://couchdb.apache.org/">CouchDB</a> is written in Erlang. Apart from having <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>, which is common for functional programming languages, Erlang also features so-called guards, which are patterns with additional conditions. Consider the following Erlang code snippet (<a href="http://www.erlang.org/doc/getting_started/seq_prog.html">source</a>):</p>
<pre class="sputcode">
list_max([Head|Rest]) -> list_max(Rest, Head).

list_max([], Res)                    -> Res;
list_max([Head|Rest], Result_so_far)
           when Head > Result_so_far -> list_max(Rest, Head);
list_max([Head|Rest], Result_so_far) -> list_max(Rest, Result_so_far).
</pre>
<div style="float:right">
  <a href="{% amazon sicp %}"><img src="{% bookcover sicp %}" /></a>
</div>
<p>The guard here is the <span class="sputcode">when Head &#8230;</span> part.</p>
<p>I was recently introduced to <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> through the classic book <a href="{% amazon sicp %}">Structure and Interpretation of Computer Programs</a>. Actually, that book treats <a href="http://groups.csail.mit.edu/mac/projects/scheme/">MIT Scheme</a>, one of many flavours of Lisp. The syntax and semantics of Lisp is extremely simple and (almost) everything is composed by parentheses, identifiers and white-space. Reading Lisp code takes some getting used to, consider, e.g., the following function definition:</p>
<pre class="sputcode">
(define (fib n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fib (- n 1)) (fib (- n 2))))))
</pre>
<p>(Appropriate new-lines and indentation helps a great deal on the readability, though). Lisp also enables assignments and is therefore not pure. In fact, both imperative and functional programming approaches can be used.</p>
<div style="clear:both"></div>
<p>I plan to include more on functional programming languages on this blog in the future.</p>
