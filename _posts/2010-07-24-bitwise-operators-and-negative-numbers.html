---
layout: wppost
title: Bitwise Operators and Negative Numbers
author: Jan Marthedal Rasmussen
excerpt: ! "When representing integers using a fixed number of bits, negative numbers
  are typically represented using <a href=\"http://en.wikipedia.org/wiki/Two's_complement\">two's
  complement</a>. If using <span class=\"mthi\">n</span> bit numbers, the
  two's complement of a number <span class=\"mthi\">x</span> with <span class=\"mthn\">0</span>
  <span class=\"mths\">&le;</span> <span class=\"mthi\">x</span> <span class=\"mths\"><</span>
  <span class=\"mthn\">2</span><sup><span class=\"mthi\">n</span></sup>
  is <span class=\"mths\">(</span><span class=\"mthi\">-x</span><span class=\"mths\">)</span>
  <span class=\"mtho\">mod</span> <span class=\"mthn\">2</span><sup><span
  class=\"mthi\">n</span></sup> <span class=\"mths\">=</span> <span class=\"mthn\">2</span><sup><span
  class=\"mthi\">n</span></sup> <span class=\"mths\">-</span> <span class=\"mthi\">x</span>.
  But what do you do if you want to work with unbounded/multiple-precision integers?
  Fixing <span class=\"mthi\">x</span> and letting the number of bits go to infinity,
  you will notice that increasing <span class=\"mthi\">n</span> by one simply
  adds a 1 at the left. For instance,\r\n\r\n"
date: 2010-07-24 19:55:05.000000000 +02:00
categories:
- mathematics
tags:
- multiple-precision
- numbers project
- bitwise operators
- number representation
---
<p>When representing integers using a fixed number of bits, negative numbers are typically represented using <a href="http://en.wikipedia.org/wiki/Two's_complement">two&#8217;s complement</a>. If using <span class="mthi">n</span> bit numbers, the two&#8217;s complement of a number <span class="mthi">x</span> with <span class="mthn">0</span> <span class="mths">&le;</span> <span class="mthi">x</span> <span class="mths">&lt;</span> <span class="mthn">2</span><sup><span class="mthi">n</span></sup> is <span class="mths">(</span><span class="mthi">-x</span><span class="mths">)</span> <span class="mtho">mod</span> <span class="mthn">2</span><sup><span class="mthi">n</span></sup> <span class="mths">=</span> <span class="mthn">2</span><sup><span class="mthi">n</span></sup> <span class="mths">-</span> <span class="mthi">x</span>. But what do you do if you want to work with unbounded/multiple-precision integers? Fixing <span class="mthi">x</span> and letting the number of bits go to infinity, you will notice that increasing <span class="mthi">n</span> by one simply adds a 1 at the left. For instance,</p>
<span></span>
<div class="display-block">
&nbsp;1975 = (11110110111)<sub>2</sub><br />
-1975 = <span class="mthn">2</span><sup><span class="mthn">12</span></sup> &#8211; 1975 = (100001001001)<sub>2</sub> &nbsp; (<span class="mthi">n</span></sup> <span class="mths">=</span> <span class="mthn">12</span>)<br />
-1975 = <span class="mthn">2</span><sup><span class="mthn">13</span></sup> &#8211; 1975 = (1100001001001)<sub>2</sub> &nbsp; (<span class="mthi">n</span></sup> <span class="mths">=</span> <span class="mthn">13</span>)<br />
-1975 = <span class="mthn">2</span><sup><span class="mthn">20</span></sup> &#8211; 1975 = (11111111100001001001)<sub>2</sub> &nbsp; (<span class="mthi">n</span></sup> <span class="mths">=</span> <span class="mthn">20</span>)<br />
-1975 = (&#8230;1111111111111100001001001)<sub>2</sub> &nbsp; (<span class="mthi">n</span></sup> <span class="mths">=</span> <span class="mths">&#8734;</span>)
</div>
<p>(This can be made more rigorous using <a href="http://en.wikipedia.org/wiki/P-adic">2-adic numbers</a>). Conversely, every binary number with infinitely many 1&#8242;s to the left corresponds to a negative integer.</p>
<p>Notice the important special case -1 = (&#8230;1111)<sub>2</sub>. If <span class="overline">x</span> denotes <i>bitwise not</i> of x, where each bit is flipped from 0 to 1 and vice versa, we observe that</p>
<div class="display-block">
x + <span class="overline">x</span> = &#8230;1111 = -1,
</div>
<p>from which we have the important identity</p>
<div class="display-block">
<span class="overline">x</span> = -1 &#8211; x.
</div>
<p>This makes bitwise not equivalent to a simple subtraction. Notice how bitwise not turns a non-negative integer into a negative integer and vice versa.</p>
<p>Let us turn to general bitwise operators. Consider a function that maps two bits to a single bit. Given such a function and two non-negative integers, we can apply the function to the zeroth bit of both numbers to obtain the zeroth bit of the result, then apply the function to the first bit of both numbers to obtain the first bit of the result, and so forth. In this way, any binary bit-operator {0,1}<sup>2</sup> &rarr; {0,1} can be extended to work on any non-negative integer (and as we shall see, any integer). There are 16 possible binary bit-operators:</p>
<div class="spec1">
<table rules=groups frame=box>
<colgroup span="1"></colgroup>
<colgroup span="1"></colgroup>
<colgroup span="4"></colgroup>
<thead>
<tr>
<td></td>
<td>x</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>x &amp; y</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td><span class="overline">x</span> &amp; y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>y</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>x &amp; <span class="overline">y</span></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>x &oplus; y</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>x | y</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
<tbody>
<tr>
<td>8</td>
<td><span class="overline">x | y</span></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td><span class="overline">x &oplus; y</span></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td><span class="overline">x</span></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>11</td>
<td><span class="overline">x</span> | y</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>12</td>
<td><span class="overline">y</span></td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>13</td>
<td>x | <span class="overline">y</span></td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td><span class="overline">x &amp; y</span></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>15</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>The first column of the table enumerates the functions from 0 to 15 (such that the binary representation of each number corresponds to the outputs). We see that exactly the functions 0-7 map (0,0) to 0, meaning that only these functions will map two non-negative integers to a non-negative integer.</p>
<p>The second column shows expressions for the functions using the well-known operators <i>bitwise and</i>, x &amp; y, <i>bitwise or (inclusive or)</i>, x | y, <i>bitwise xor (exclusive or)</i>, x &oplus; y, and <i>bitwise not</i>, <span class="overline">x</span>. The table simultaneously define these operators.</p>
<p>We can now formulate the goal of this article: Using only the bitwise operators that map non-negative integers to non-negative integers, together with usual integer arithmetic, how can we implement all 16 functions? The approach is quite simple: Use <i>bitwise not</i> to transform any negative integer into a non-negative integer, apply one of the functions 0-7, and then possibly apply <i>bitwise not</i> again to obtain the result.</p>
<p>Before proceeding, we need some fundamental identities. First, symmetry:</p>
<div class="display-block">
x &amp; y = y &amp; x, &nbsp;&nbsp; x | y = y | x, &nbsp;&nbsp; x &oplus; y = y &oplus; x,
</div>
<p>Then, <a href="http://en.wikipedia.org/wiki/De_Morgan's_laws">De Morgan&#8217;s laws</a>:</p>
<div class="display-block">
<span class="overline">x &amp; y</span> = <span class="overline">x</span> | <span class="overline">y</span>, &nbsp;&nbsp; <span class="overline">x | y</span> = <span class="overline">x</span> &amp; <span class="overline">y</span>,
</div>
<p>Finally some useful rules for exlusive or:</p>
<div class="display-block">
x &oplus; y = <span class="overline">x</span> &oplus; <span class="overline">y</span>, &nbsp;&nbsp; <span class="overline">x &oplus; y</span> = <span class="overline">x</span> &oplus; y = x &oplus; <span class="overline">y</span>.
</div>
<p>All of these are easily proved since they (by definition) operate <i>bitwise</i>. This means that you only have to consider one-bit numbers, which means only four different cases to check.</p>
<p>The only non-trivial operators among the functions 0-7 are x &amp; y, x | y, x &oplus; y, and x &amp; <span class="overline">y</span>. We will use the notation x <span class="overline">&amp;</span> y = x &amp; <span class="overline">y</span>. Note how <span class="overline">&amp;</span> is <i>not</i> symmetric. The only non-trivial operators among the functions 8-15 are <span class="overline">x &amp; y</span>, <span class="overline">x | y</span>, x | <span class="overline">y</span>, and <span class="overline">x &oplus; y</span>. Considering these eight cases, along with whether x and y are negative or not, we get the following table:</p>
<table border="1" style="border-collapse:collapse; background:#F2F2F2;">
<tr>
<td></td>
<td>x &ge; 0, y &ge; 0</td>
<td>x &ge; 0, y &lt; 0</td>
<td>x &lt; 0, y &ge; 0</td>
<td>x &lt; 0, y &lt; 0</td>
</tr>
<tr>
<td>x &amp; y</td>
<td>x &amp; y</td>
<td>x <span class="overline">&amp;</span> <span class="overline">y</span></td>
<td>y <span class="overline">&amp;</span> <span class="overline">x</span></td>
<td><span class="overline2"><span class="overline">x</span> | <span class="overline">y</span></span></td>
</tr>
<tr>
<td>x | y</td>
<td>x | y</td>
<td><span class="overline2"><span class="overline">y</span> <span class="overline">&amp;</span> x</span></td>
<td><span class="overline2"><span class="overline">x</span> <span class="overline">&amp;</span> y</span></td>
<td><span class="overline2"><span class="overline">x</span> &amp; <span class="overline">y</span></span></td>
</tr>
<tr>
<td>x <span class="overline">&amp;</span> y</td>
<td>x <span class="overline">&amp;</span> y</td>
<td>x &amp; <span class="overline">y</span></td>
<td><span class="overline2"><span class="overline">x</span> | y</span></td>
<td><span class="overline">y</span> <span class="overline">&amp;</span> <span class="overline">x</span></td>
</tr>
<tr>
<td>x &oplus; y</td>
<td>x &oplus; y</td>
<td><span class="overline2">x &oplus; <span class="overline">y</span></span></td>
<td><span class="overline2"><span class="overline">x</span> &oplus; y</span></td>
<td><span class="overline">x</span> &oplus; <span class="overline">y</span></td>
</tr>
<tr>
<td><span class="overline">x &amp; y</span></td>
<td><span class="overline">x &amp; y</span></td>
<td><span class="overline2">x <span class="overline">&amp;</span> <span class="overline">y</span></span></td>
<td><span class="overline2">y <span class="overline">&amp;</span> <span class="overline">x</span></span></td>
<td><span class="overline">x</span> | <span class="overline">y</span></span></td>
</tr>
<tr>
<td><span class="overline">x | y</span></td>
<td><span class="overline">x | y</span></td>
<td><span class="overline">y</span> <span class="overline">&amp;</span> x</td>
<td><span class="overline">x</span> <span class="overline">&amp;</span> y</td>
<td><span class="overline">x</span> &amp; <span class="overline">y</span></td>
</tr>
<tr>
<td>x | <span class="overline">y</span></td>
<td><span class="overline2">y <span class="overline">&amp;</span> x</span></td>
<td>x | <span class="overline">y</span></td>
<td><span class="overline2"><span class="overline">x</span> &amp; y</span></td>
<td><span class="overline2"><span class="overline">x</span> <span class="overline">&amp;</span> <span class="overline">y</span></span></td>
</tr>
<tr>
<td><span class="overline">x &oplus; y</span></td>
<td><span class="overline">x &oplus; y</span></td>
<td>x &oplus; <span class="overline">y</span></td>
<td><span class="overline">x</span> &oplus; y</td>
<td><span class="overline2"><span class="overline">x</span> &oplus; <span class="overline">y</span></span></td>
</tr>
</table>
<p>Here, we have used only the identities shown earlier. Of course, we need to convert each bitwise not into a subtraction to complete the task. For instance, with x &lt; 0, y &ge; 0 we have</p>
<div class="display-block">
x | <span class="overline">y</span> = <span class="overline2"><span class="overline">x</span> &amp; y</span> = -1 &#8211; ((-1 &#8211; x) &amp; y)
</div>
<p>This way, the bitwise and-operation is being applied to non-negative numbers and we see that the result is always negative.</p>
<p>We can now, with assistance from the table above, apply any of the 16 binary bitwise operators to <i>any</i> pair of integers, without restricting ourselves to working with a fixed number of bits.</p>
<div style="float:right"><a href="{% amazon hackers-delight %}"><img src="{% bookcover hackers-delight %}" /></a></div>
<div style="float:right"><a href="{% amazon taocp4f1 %}"><img src="{% bookcover taocp4f1 %}" /></a></div>
<p>For further reading related to the binary representation of numbers, I recommend <a href="{% amazon taocp4f1 %}">The Art of Computer Programming, Volume 4, Fascicle 1: Bitwise Tricks &amp; Techniques and Binary Decision Diagrams</a> by <a href="http://www-cs-faculty.stanford.edu/~knuth/">Donald E. Knuth</a> and <a href="{% amazon hackers-delight %}">Hacker&#8217;s Delight</a> by Henry S. Warren, Jr.</p>
