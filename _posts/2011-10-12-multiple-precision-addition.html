---
layout: wppost
title: Multiple-Precision Addition
author: Jan Marthedal Rasmussen
excerpt: ! "This post will cover a basic addition algorithm for multiple-precision
  non-negative integers. The algorithm is based upon that presented in Section 4.3.1,
  <em>The Classical Algorithms</em>, of <a href=\"http://www-cs-faculty.stanford.edu/~knuth/taocp.html\">The
  Art of Computer Programming</a>, Volume 2, by <a href=\"http://www-cs-faculty.stanford.edu/~knuth/\">Donald
  E. Knuth</a>. The notation and bounds used in this post were presented in a <a href=\"/2011/10/multiple-precision-number-representation.html\">previous
  post</a>.\r\n\r\nWe consider adding two <span class=\"mthi\">n</span>-digit numbers
  with \\(n \\geq 1\\), \\(u=(u_{n-1} \\ldots u_1 u_0)_b\\) and \\(v=(v_{n-1} \\ldots
  v_1 v_0)_b\\)."
date: 2011-10-12 12:27:47.000000000 +02:00
categories:
- programming
tags:
- algorithms
- multiple-precision
- numbers project
- basic theory
---
<div style="float:right"><a href="{% amazon taocp2 %}"><img src="{% bookcover taocp2 %}" /></a></div>
<p>This post will cover a basic addition algorithm for multiple-precision non-negative integers. The algorithm is based upon that presented in Section 4.3.1, <em>The Classical Algorithms</em>, of <a href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html">The Art of Computer Programming</a>, Volume 2, by <a href="http://www-cs-faculty.stanford.edu/~knuth/">Donald E. Knuth</a>. The notation and bounds used in this post were presented in a <a href="/2011/10/multiple-precision-number-representation.html">previous post</a>.</p>
<p>We consider adding two <span class="mthi">n</span>-digit numbers with \(n \geq 1\), \(u=(u_{n-1} \ldots u_1 u_0)_b\) and \(v=(v_{n-1} \ldots v_1 v_0)_b\). <span></span>Since \(b^{n-1} \leq u, v \leq b^n &#8211; 1\) we have \(2 b^{n-1} \leq u+v \leq 2 b^n &#8211; 2\) which, when using the fact that \(b \geq 2\), leads to \(b^{n-1} \leq u+v \leq b^{n+1} &#8211; 1\) (note how a tighter bound of the form \(b^p \leq u+v \leq b^q &#8211; 1\) is not possible).</p>
<p>This means that \(u+v\) can be represented using \(n\) or \(n+1\) digits, so we set \(w=(w_n \ldots w_1 w_0)_b\).</p>
<p>Assuming \(k_0\) is set to some initial value (more on this below) we now have the following algorithm:
\[
\begin{aligned}
w_i     &amp;\leftarrow (u_i + v_i + k_i) \;\mbox{mod}\; b \\
k_{i+1} &amp;\leftarrow \lfloor (u_i + v_i + k_i)/b \rfloor
\end{aligned}
\]
for \(i = 0, 1, \ldots, n-1\), and finally \(w_n \leftarrow k_n\).</p>
<p>The algorithm sets the digits of <span class="mthi">w</span> such that \(w = u+v+k_0\). This can be seen by first observing that \(p = p \;\mbox{mod}\; b + \lfloor p/b \rfloor b\) for any integer <span class="mthi">p</span>. Using this relation on the variables set during the algorithm, we have
\[
u_i + v_i + k_i = w_i + k_{i+1} b
\]
for \(i = 0, 1, \ldots, n-1\). We now have
\[
\begin{aligned}
u+v &amp;= \sum_{i=0}^{n-1} (u_i+v_i) b^i = \sum_{i=0}^{n-1} (u_i+v_i+k_i) b^i - \sum_{i=0}^{n-1} k_i b^i \\
    &amp;= \sum_{i=0}^{n-1} (w_i+k_{i+1} b) b^i - \sum_{i=0}^{n-1} k_i b^i = \sum_{i=0}^{n-1} w_i b^i + k_n b^n - k_0,
\end{aligned}
\]
showing that \(w=u+v+k_0\).</p>
<p>It is clear that each resulting digits of <span class="mthi">w</span> satisfies \(0 \leq w_i \leq b-1\) for \(i = 0, \ldots, n-1\), as it should. The value of \(w_n\), though, depends on \(k_n\).</p>
<p>Assume that \(0 \leq k_i \leq 1\) for some \(i=0, \ldots, n-1\). Since \(u_i+v_i+k_i \leq b-1+b-1+1 = 2b-1\) we see that \(k_{i+1} = \lfloor (u_i + v_i + k_i)/b \rfloor \leq 1\). So if we have \(0 \leq k_0 \leq 1\) as initial value for the algorithm we have, by induction, that \(0 \leq k_i \leq 1\) for all \(i=0, \ldots, n\).</p>
<p>This shows how (not surprisingly) \(k_0\) can be seen as an &#8220;initial carry&#8221; and how each \(k_{i+1}\) is <span class="mthn">0</span> or <span class="mthn">1</span>, depending on whether a carry was produced from the <span class="mthi">i</span>th digit addition.</p>
