---
layout: wppost
title: C++ Templates and Usual Arithmetic Conversions
author: Jan Marthedal Rasmussen
excerpt: ! "If you add a <span class=\"sputcode\">short int</span> and a <span
  class=\"sputcode\">char</span> in C++, what is the resulting type? What if you
  subtract a <span class=\"sputcode\">long int</span> from an <span class=\"sputcode\">unsigned
  int</span>? The answers actually depend on the compiler and the target architecture
  (<span class=\"sputcode\">int</span> or <span class=\"sputcode\">unsigned</span>
  in the first case and <span class=\"sputcode\">long int</span> or <span class=\"sputcode\">unsigned
  long int</span> in the second). This article lists the rules from the current
  C++ standard and gives an example of how the type can be resolved at compile time
  using templates.\r\n\r\n"
date: 2010-08-28 11:56:11.000000000 +02:00
categories:
- programming
tags:
- C++
- generic programming
- templates
- data types
---
<p>If you add a <span class="sputcode">short int</span> and a <span class="sputcode">char</span> in C++, what is the resulting type? What if you subtract a <span class="sputcode">long int</span> from an <span class="sputcode">unsigned int</span>? The answers actually depend on the compiler and the target architecture (<span class="sputcode">int</span> or <span class="sputcode">unsigned</span> in the first case and <span class="sputcode">long int</span> or <span class="sputcode">unsigned long int</span> in the second). This article lists the rules from the current C++ standard and gives an example of how the type can be resolved at compile time using templates.</p>
<span></span>
<h3>Introduction</h3>
<div style="float:right"><a href="{% amazon stroustrup %}"><img src="{% bookcover stroustrup %}" /></a></div>
<p>Let me first note that I will be referring to the current C++ standard from 1998 (with a minor revision in 2003). This standard is described in <a href="{% amazon stroustrup %}">The C++ Programming Language</a> by <a href="http://www2.research.att.com/~bs/">Bjarne Stroustrup</a>. It can also be found <a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2/">online</a>.</p>
<p>In C++, the <i>integer types</i> are <span class="sputcode">short int</span>, <span class="sputcode">int</span>, <span class="sputcode">long int</span> and the unsigned versions of these. The integer types together with the boolean type (<span class="sputcode">bool</span>) and the character types (plain/<span class="sputcode">signed</span>/<span class="sputcode">unsigned</span> <span class="sputcode">char</span> and <span class="sputcode">wchar_t</span>) are called <i>integral types</i>. The integral types together with the floating-point types (<span class="sputcode">float</span>, <span class="sputcode">double</span>, and <span class="sputcode">long double</span>) are called <i>arithmetic types</i>.</p>
<h3>Resolving the Return Type</h3>
<p>Consider having the function <span class="sputcode">fct</span> overloaded with one function for each arithmetic type, for example:</p>
<pre class="sputcode">
void fct(short v)          { std::cout &lt;&lt; "short "          &lt;&lt; v &lt;&lt; std::endl; }
void fct(unsigned short v) { std::cout &lt;&lt; "unsigned short " &lt;&lt; v &lt;&lt; std::endl; }
void fct(int v)            { std::cout &lt;&lt; "int "            &lt;&lt; v &lt;&lt; std::endl; }
void fct(unsigned v)       { std::cout &lt;&lt; "unsigned "       &lt;&lt; v &lt;&lt; std::endl; }
...
</pre>
<p>and so on. If you now have the following little routine:</p>
<pre class="sputcode">
void g(short int a, char b) {
  fct(a + b);
}
</pre>
<p>which instance of <span class="sputcode">fct</span> is called? This is another way of asking the question that started this article.</p>
<p>When a binary operator (<span class="sputcode">+</span>, <span class="sputcode">-</span>, <span class="sputcode">*</span>, <span class="sputcode">/</span>, <span class="sputcode">%</span>) is applied to operands with arithmetic types, the C++ compiler must do the following:</p>
<ul>
<li><b>Integral promotion</b>. Each operand is, if necessary, promoted to at least an <span class="sputcode">int</span> (to be made more precise below).</li>
<li><b>Usual arithmetic conversions</b>. Based on the (possibly promoted) types of the operands, a common type is found. Both operands are converted to this type, which will also be the resulting type.</li>
</ul>
<h3>Integral Promotions</h3>
<p>Integral promotions are defined in Section 4.5, page 4-3, from the <a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2/">online standard</a> and in Section C.6.1, page 833, from <a href="{% amazon stroustrup %}">The C++ Programming Language</a>. If we ignore enumerations and bit-fields, they can be summed up as follows:</p>
<ul>
<li>A <span class="sputcode">char</span>, <span class="sputcode">signed char</span>, <span class="sputcode">signed char</span>, <span class="sputcode">short int</span>, <span class="sputcode">unsigned short int</span> is converted to <span class="sputcode">int</span> if <span class="sputcode">int</span> can represent all the values of the source type; otherwise, it is converted to an <span class="sputcode">unsigned int</span>.</li>
<li><span class="sputcode">wchar_t</span> is converted to the first of the following types that can represent all the values of <span class="sputcode">wchar_t</span>: <span class="sputcode">int</span>, <span class="sputcode">unsigned int</span>, <span class="sputcode">long</span>, <span class="sputcode">unsigned long</span>.</li>
<li><span class="sputcode">bool</span> is converted to <span class="sputcode">int</span>.</li>
</ul>
<h3>Usual Arithmetic Conversions</h3>
<p>The rules for usual arithmetic conversions can be found in Section 5, page 5-2, from the <a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2/">online standard</a> and in Section C.6.3, page 836, from <a href="{% amazon stroustrup %}">The C++ Programming Language</a>. Assuming integral promotions have been performed (if needed), the usual arithmetic conversions are in essense the following:</p>
<ul>
<li>If one operand is a <span class="sputcode">long int</span> and the other <span class="sputcode">unsigned int</span>, then if a <span class="sputcode">long int</span> can represent all the values of an <span class="sputcode">unsigned int</span>, the <span class="sputcode">unsigned int</span> shall be converted to a <span class="sputcode">long int</span>; otherwise both operands shall be converted to <span class="sputcode">unsigned long int</span>.</li>
<li>Otherwise, find the highest ranking type among the operands and convert the other operand to this type. The relevant types listed from high to low rank are: <span class="sputcode">long double</span>, <span class="sputcode">double</span>, <span class="sputcode">float</span>, <span class="sputcode">unsigned long</span>, <span class="sputcode">long</span>, <span class="sputcode">unsigned</span>, <span class="sputcode">int</span>.</li>
</ul>
<h3>Using Templates To Get The Type</h3>
<p>Those were the rules in written form. Imagine now that we have, e.g., the following routine:</p>
<pre class="sputcode">
template &lt;typename A, typename B&gt;
<i>some-type</i> add(const A&#038; a, const B&#038; b) { return a + b; }
</pre>
<p>We would like the types of <span class="sputcode">add(a, b)</span> and <span class="sputcode">a + b</span> to be identical when both <span class="sputcode">a</span> and <span class="sputcode">b</span> are arithmetic types.</p>
<p>First, promotions. By default, a type is not promoted:</p>
<pre class="sputcode">
template &lt;typename T&gt;
struct promote { typedef T type; };
</pre>
<p>We then use template specializations for the types that need to be promoted. Some of these are easy:</p>
<pre class="sputcode">
template &lt;&gt;
struct promote&lt;signed short&gt; { typedef int type; };
template &lt;&gt;
struct promote&lt;bool&gt; { typedef int type; };
</pre>
<p>For the rest, we need a sort of if-then-else for choosing a type:</p>
<pre class="sputcode">
template &lt;bool C, typename T, typename F&gt;
struct choose_type { typedef F type; };
template &lt;typename T, typename F&gt;
struct choose_type&lt;true, T, F&gt; { typedef T type; };
</pre>
<p>So the boolean value of the first argument determines whether to choose the type <span class="sputcode">T</span> (if true) or <span class="sputcode">F</span> (if false). We now have:</p>
<pre class="sputcode">
template &lt;&gt;
struct promote&lt;unsigned short&gt; {
  typedef choose_type&lt;sizeof(short) &lt; sizeof(int), int, unsigned&gt;::type type;
};
template &lt;&gt;
struct promote&lt;signed char&gt; {
  typedef choose_type&lt;sizeof(char) &lt;= sizeof(int), int, unsigned&gt;::type type;
};
template &lt;&gt;
struct promote&lt;unsigned char&gt; {
  typedef choose_type&lt;sizeof(char) &lt; sizeof(int), int, unsigned&gt;::type type;
};
template &lt;&gt;
struct promote&lt;char&gt;
 : public promote&lt;choose_type&lt;std::numeric_limits&lt;char&gt;::is_signed,
                              signed char, unsigned char&gt;::type&gt; {};
</pre>
<p>This last one for plain <span class="sputcode">char</span> is needed because C++ considers <span class="sputcode">char</span>, <span class="sputcode">signed char</span>, and <span class="sputcode">unsigned char</span> to be three distinct types. The standard does not specify whether <span class="sputcode">char</span> is signed or not. (The <span class="sputcode">numeric_limits</span> template is defined in the <span class="sputcode">limits</span> header.)</p>
<p>Finally, to promote <span class="sputcode">wchar_t</span>:</p>
<pre class="sputcode">
template &lt;&gt;
struct promote&lt;wchar_t&gt; {
  typedef choose_type&lt;
            std::numeric_limits&lt;wchar_t&gt;::is_signed,
            choose_type&lt;sizeof(wchar_t) &lt;= sizeof(int), int, long&gt;::type,
            choose_type&lt;sizeof(wchar_t) &lt;= sizeof(int), unsigned, unsigned long&gt;::type
          &gt;::type type;
};
</pre>
<p>We can now turn to the usual arithmetic conversions. First, we promote each type, if necessary:</p>
<pre class="sputcode">
template &lt;typename A, typename B&gt;
struct resolve_uac : public resolve_uac2&lt;typename promote&lt;A&gt;::type,
                                         typename promote&lt;B&gt;::type> {};
</pre>
<p>This ensures that the type arguments for <span class="sputcode">resolve_uac2</span> are at least <span class="sputcode">int</span>s. We then introduce ranks for those types:</p>
<pre class="sputcode">
template &lt;typename T&gt; struct type_rank;
template &lt;&gt; struct type_rank&lt;int&gt;           { static const int rank = 1; };
template &lt;&gt; struct type_rank&lt;unsigned&gt;      { static const int rank = 2; };
template &lt;&gt; struct type_rank&lt;long&gt;          { static const int rank = 3; };
template &lt;&gt; struct type_rank&lt;unsigned long&gt; { static const int rank = 4; };
template &lt;&gt; struct type_rank&lt;float&gt;         { static const int rank = 5; };
template &lt;&gt; struct type_rank&lt;double&gt;        { static const int rank = 6; };
template &lt;&gt; struct type_rank&lt;long double&gt;   { static const int rank = 7; };
</pre>
<p>Now we can pick the type with the highest rank:</p>
<pre class="sputcode">
template &lt;typename A, typename B&gt;
struct resolve_uac2 {
  typedef typename choose_type&lt;
            type_rank&lt;A&gt;::rank &gt;= type_rank&lt;B&gt;::rank, A, B
          &gt;::type return_type;
};
</pre>
<p>Finally we need to deal with the special case where one type is <span class="sputcode">long int</span> and the other is <span class="sputcode">unsigned int</span>:</p>
<pre class="sputcode">
template &lt;&gt;
struct resolve_uac2&lt;long, unsigned&gt; {
  typedef choose_type&lt;sizeof(long) == sizeof(unsigned),
                      unsigned long, long&gt;::type return_type;
};
template &lt;&gt;
struct resolve_uac2&lt;unsigned, long&gt; : public resolve_uac2&lt;long, unsigned&gt; {};
</pre>
<p>We can now write the <span class="sputcode">add</span> routine from earlier as:</p>
<pre class="sputcode">
template &lt;typename A, typename B&gt;
typename resolve_uac&lt;A, B&gt;::return_type add(const A&#038; a, const B&#038; b)
{ return a + b; }
</pre>
<p>and the return type will match that of the <span class="sputcode">+</span> operation. Note that the arguments to <span class="sputcode">add</span> have to be arithmetic types (because of the <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution-failure-is-not-an-error</a> principle).</p>
<h3>Remarks</h3>
<p>The rules and implementation above should be complete with the exception of enumerations and bit-fields, see the links to the standard for the missing pieces. Note also that the rules for promotions and usual arithmetic conversions will change (slightly) in the upcoming C++0x standard, see the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">C++0x draft</a>, Section 5, page 84.</p>
