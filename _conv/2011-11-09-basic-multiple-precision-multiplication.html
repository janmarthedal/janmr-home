---
layout: post
status: publish
published: true
title: Basic Multiple-Precision Multiplication
author: Jan Marthedal Rasmussen
author_login: sput
author_email: jmr@kanooth.com
author_url: http://kanooth.com/blog/
excerpt: ! "After addressing multiple-precision <a href=\"&#47;blog&#47;2011&#47;10&#47;multiple-precision-addition.html\">addition<&#47;a>
  and <a href=\"&#47;blog&#47;2011&#47;10&#47;multiple-precision-subtraction.html\">subtraction<&#47;a>,
  we now turn to multiplication of two multiple-precision numbers. Once again, we
  use the number representation and notation <a href=\"&#47;blog&#47;2011&#47;10&#47;multiple-precision-number-representation.html\">introduced
  earlier<&#47;a>.\r\n\r\nSeveral algorithms exist for doing multiple-precision multiplication.
  This post will present the basic, pencil-and-paper-like method. Basically, it consists
  of two parts: Multiplying a number by a single digit and adding together the sub-results,
  aligned appropriately.\r\n\r\n"
wordpress_id: 2560
wordpress_url: http://kanooth.com/blog/?p=2560
date: 2011-11-09 09:55:46.000000000 +01:00
categories:
- programming
tags:
- algorithms
- multiple-precision
- numbers project
- basic theory
---
<p>After addressing multiple-precision <a href="/blog/2011/10/multiple-precision-addition.html">addition</a> and <a href="/blog/2011/10/multiple-precision-subtraction.html">subtraction</a>, we now turn to multiplication of two multiple-precision numbers. Once again, we use the number representation and notation <a href="/blog/2011/10/multiple-precision-number-representation.html">introduced earlier</a>.</p>
<p>Several algorithms exist for doing multiple-precision multiplication. This post will present the basic, pencil-and-paper-like method. Basically, it consists of two parts: Multiplying a number by a single digit and adding together the sub-results, aligned appropriately.</p>
<p><span id="more-2560"></span></p>
<h3>Multiple digits times a single digit</h3>
<p>Let us first consider multiplying an <span class="mthi">n</span>-digit multiple-precision integer by a single digit. More precisely, we wish to compute \(z \leftarrow \alpha v + y + k_0\) where<br />
\[<br />
v = (v_{n-1} \ldots v_1 v_0)_b, \quad 1 \leq \alpha \leq b-1, \quad y = (y_{n-1} \ldots y_1 y_0)_b, \quad 0 \leq k_0 \leq b-1.<br />
\]<br />
Using this information it is straightforward to show that \(b^{n-1} \leq z \leq b^{n+1}-1\), which implies that the result will fit into \(n\) or \(n+1\) digits, so we set \(z = (z_n \ldots z_1 z_0)_b\), where \(z_n\) may be zero.</p>
<p>We now have the algorithm:<br />
\[<br />
\begin{aligned}<br />
z_i &#038;\leftarrow (\alpha v_i + y_i + k_i) \;\mbox{mod}\; b, \\<br />
k_{i+1} &#038;\leftarrow \left\lfloor \frac{\alpha v_i + y_i + k_i}{b} \right\rfloor,<br />
\end{aligned}<br />
\]<br />
for \(i = 0, 1, \ldots, n-1\) and finally setting \(z_n = k_n\).</p>
<p>To realize that the algorithm computes what it is supposed to, observe first that<br />
\[<br />
\alpha v_i + y_i + k_i = (\alpha v_i + y_i + k_i) \;\mbox{mod}\; b + \left\lfloor (\alpha v_i + y_i + k_i)/b \right\rfloor b = z_i + k_{i+1} b.<br />
\]<br />
Then we have<br />
\[<br />
\begin{aligned}<br />
\alpha v + y &#038;= \sum_{i=0}^{n-1} (\alpha v_i + y_i) b^i = \sum_{i=0}^{n-1} (\alpha v_i + y_i + k_i) b^i - \sum_{i=0}^{n-1} k_i b^i \\<br />
             &#038;= \sum_{i=0}^{n-1} (z_i + k_{i+1} b) b^i - \sum_{i=0}^{n-1} k_i b^i = \sum_{i=0}^{n-1} z_i b^i + \sum_{i=0}^{n-1} k_{i+i} b^{i+1} - \sum_{i=0}^{n-1} k_i b^i \\<br />
             &#038;= \sum_{i=0}^{n-1} z_i b^i + z_n b^n - k_0 = z - k_0,<br />
\end{aligned}<br />
\]<br />
which is what we wanted.</p>
<p>From the expression for \(z_i\) we see that they naturally fit into a digit, that is, \(0 \leq z_i \leq b-1\) for \(i = 0, 1, \ldots, n-1\). But what about the \(k_i\)&#8217;s and thus also \(z_n\)? Assume that \(0 \leq k_i \leq b-1\). We then have<br />
\(<br />
\alpha v_i + y_i + k_i \leq (b-1) + (b-1)(b-1) + (b-1) = b^2-1,<br />
\)<br />
which implies that \(k_{i+1} = \lfloor (\alpha v_i + y_i + k_i)/b \rfloor \leq b-1\). Since we have also assumed \(0 \leq k_0 \leq b-1\) we have, by induction, that \(0 \leq z_i \leq b-1\) for \(i = 0, 1, \ldots, n\).</p>
<h3>Multiple digits times multiple digits</h3>
<p>We now turn to multiplying two multiple-precision numbers. More specifically, we wish to multiply<br />
\[<br />
u = (u_{m-1} \ldots u_1 u_0)_b, \quad \mbox{and} \quad v = (v_{n-1} \ldots v_1 v_0)_b,<br />
\]<br />
which implies \(b^{m+n-2} \leq u v &lt; b^{m+n}\). So we set \(w = (w_{m+n-1} \ldots w_1 w_0)_b\) and aim to compute<br />
\[<br />
w \leftarrow u v = \sum_{i=0}^{m-1} u_i v b^i.<br />
\]<br />
We observe two things:</p>
<ol>
<li>Multiplication by \(b^i\) corresponds to shifting left the number of digits given by <span class="mthi">i</span>.
<li>The product \(u_i v\) is of type single-digit times multiple-digit and can be computed using the algorithm from the previous section.</li>
</ol>
<p>Putting these pieces together we get:<br />
\[<br />
\begin{aligned}<br />
(w_n \ldots w_1 w_0)_b           &#038;\leftarrow u_0 v, \\<br />
(w_{n+1} \ldots w_2 w_1)_b       &#038;\leftarrow (w_n \ldots w_2 w_1) + u_1 v, \\<br />
                                 &#038;\vdots \\<br />
(w_{n+m-1} \ldots w_m w_{m-1})_b &#038;\leftarrow (w_{n+m-2} \ldots w_m w_{m-1})_b + u_{m-1} v.<br />
\end{aligned}<br />
\]</p>
<p>The algorithm can actually be generalized slightly if we compute<br />
\[<br />
w \leftarrow (w_{n-1} \ldots w_1 w_0)_b + u \; v<br />
\]<br />
instead. All we need to do is replace the first step in the algorithm by<br />
\[<br />
(w_n \ldots w_1 w_0)_b \leftarrow (w_{n-1} \ldots w_1 w_0)_b + u_0 v.<br />
\]</p>
