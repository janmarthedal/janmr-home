---
layout: post
status: publish
published: true
title: Evaluation of Powers
author: Jan Marthedal Rasmussen
author_login: sput
author_email: jmr@kanooth.com
author_url: http://kanooth.com/blog/
excerpt: ! 'How do you efficiently compute <span class="mthi">x</span><sup><span class="mthi">n</span></sup>
  for a positive integer <span class="mthi">n</span>? Take <span class="mthi">x</span><sup><span
  class="mthn">15</span></sup> as an example. You could take <span class="mthi">x</span>
  and repeatedly multiply by <span class="mthi">x</span> 14 times. A better way to
  do it, however, is this:'
wordpress_id: 2056
wordpress_url: http://sputsoft.com/blog/?p=2056
date: 2011-01-30 16:03:57.000000000 +01:00
categories:
- programming
- mathematics
tags:
- algorithms
- numbers project
---
<p>How do you efficiently compute <span class="mthi">x</span><sup><span class="mthi">n</span></sup> for a positive integer <span class="mthi">n</span>? Take <span class="mthi">x</span><sup><span class="mthn">15</span></sup> as an example. You could take <span class="mthi">x</span> and repeatedly multiply by <span class="mthi">x</span> 14 times. A better way to do it, however, is this:<br />
<span id="more-2056"></span></p>
<ul>
<li>\(t_0=x\)</li>
<li>\(t_1=t_0 \cdot t_0 = x^2\)</li>
<li>\(t_2=t_0 \cdot t_1 = x^3\)</li>
<li>\(t_3=t_1 \cdot t_2 = x^5\)</li>
<li>\(t_4=t_3 \cdot t_3 = x^{10}\)</li>
<li>\(t_5=t_3 \cdot t_4 = x^{15}\)</li>
</ul>
<p>A shorter way to write this is \(x^1,x^2,x^3,x^5,x^{10},x^{15}\), where each quantity is obtained by multiplying two of the previous quantities together. We can write it even shorter as 1,2,3,5,10,15, where only the exponents are written. Here each number is obtained by adding together two of the previous numbers. This is called an <a href="http://en.wikipedia.org/wiki/Addition_chain">addition chain</a> and is at the heart of studying the optimal way of evaluating powers. There is no simple expression that computes the minimal number of multiplications \(a(n)\) needed to evaluate <span class="mthi">x</span><sup><span class="mthi">n</span></sup>. A <a href="http://oeis.org/A003313">list</a>, however, is available from <a href="http://oeis.org">The On-Line Encyclopedia of Integer Sequences</a>, where the first 40 entries are</p>
<div class="display-block">0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 7, 5, 6, 6, 7, 6, 7, 7, 7, 6, &#8230;</div>
<p>We see that \(a(15)=5\), which shows that the addition chain 1,2,3,5,10,15 is indeed the shortest possible, and it follows that the procedure shown above to compute <span class="mthi">x</span><sup><span class="mthn">15</span></sup> required the minimal number of multiplications.</p>
<p>Since the numbers in an addition chain grows the fastest by doubling the previous item, it is fairly easy to see that</p>
<div style="float: right;">(1)</div>
<p>\[<br />
a(n) \geq \lceil \log_2(n) \rceil \quad .<br />
\]</p>
<div style="float: right;"><img src="/book/taocp2.jpg" alt="" /><a href="/book/link.php?id=taocp2"></a></div>
<p>(This, and other results related to the evaluation of powers and addition chains can be found in <a href="/book/link.php?id=taocp2">The Art of Computer Programming, Volume 2</a>, Section 4.6.3.)</p>
<p>An algorithm that comes close to this optimal bound is the binary method, which relies on these simple relations:</p>
<ul>
<li>\(x^0 = 1\)</li>
<li>\(x^{2k} = (x^k)^2\)</li>
<li>\(x^{2k+1} = x \cdot x^{2k}\)</li>
</ul>
<p>A recursive algorithm could readily be made from these, but we wish to have an iterative algorithm. The key here is to consider the slightly more general problem of evaluating \(y \cdot x^n\). Here we have the relations:</p>
<ul>
<li>\(y \cdot x^0 = y\)</li>
<li>\(y \cdot x^{2k} = y \cdot (x^2)^k\)</li>
<li>\(y \cdot x^{2k+1} = (y \cdot x) \cdot x^{2k}\)</li>
</ul>
<p>This leads immediately to the following <span class="sputcode">C++</span> code:</p>

{% highlight cpp %}
number_t power(number_t y, number_t x, unsigned n) {
  while (n) {
    if (n % 2 == 0) {
      x *= x;
      n /= 2;
    } else {
      y *= x;
      n--;
    }
  }
  return y;
}{% endhighlight %}

<p>A slightly improved version (and maybe a bit less elegant) is the following:</p>

{% highlight cpp %}
number_t power(number_t y, number_t x, unsigned n) {
  if (!n) return y;
  while (n > 1) {
    if (n & 1) y *= x;
    x *= x;
    n >>= 1;
  }
  return y*x;
}{% endhighlight %}

<p>This algorithm performs \(\lfloor \log_2 n \rfloor\) multiplications of the type \(x \leftarrow x^2\) and \(\nu(n)\) multiplications of the type \(y \leftarrow y \cdot x\), where \(\nu(n)\) is the number of 1s in the binary representation of <span class="mthi">n</span>, so all in all it requires<br />
\[<br />
\lfloor \log_2 n \rfloor + \nu(n)<br />
\]<br />
multiplications (sequence <a href="http://oeis.org/A056792">A056792</a> at <a href="http://oeis.org">OEIS</a>).</p>
<p>So now we can evaluate \(y \cdot x^n\) fairly efficiently. To evaluate \(x^n\) we can simply use this routine by setting \(y=1\). But that wastes one multiplication because the first time we perform \(y \leftarrow y \cdot x\) it will be redundant. Instead we could use <span class="sputcode">power(x, x, n-1)</span>, but that could increase the number of multiplications for even <span class="mthi">n</span>. A good way to evaluate \(x^n\) is this:</p>

{% highlight cpp %}
number_t power(number_t x, unsigned n) {
  if (!n) return (T) 1;
  while (!(n & 1)) {
    x *= x;
    n >>= 1;
  }
  return power(x, x, n-1);
}{% endhighlight %}

<p>This way, when executing <span class="sputcode">power(x, x, n-1)</span>, <span class="sputcode">n</span> will always be uneven. This saves one multiplication compared to using just <span class="sputcode">power(1, x, n)</span>, so it requires<br />
\[<br />
\lfloor \log_2 n \rfloor + \nu(n) - 1<br />
\]<br />
multiplications (sequence <a href="http://oeis.org/A014701">A014701</a> at <a href="http://oeis.org">OEIS</a>).</p>
<p>As mentioned above, this algorithm is not optimal, but it is not bad either. In fact, 15 is the smallest value of <span class="mthi">n</span> for which the binary algorithm does not use the minimal number of multiplications. Figure 1 below compares the number of multiplications needed by the binary algorithm to the minimal number possible.</p>

<figure>
  <img src="/media/power.png" class="img-responsive" alt="Evaluation of powers">
  <figcaption>Figure 1. Number of multiplications used to evaluate the nth power.</figcaption>
</figure>

<p>Note also that we have only talked about minimizing the number of multiplications. What if a different cost is associated with each multiplication? For instance, the basic multiple-precision multiplication algorithm described in an <a href="/blog/2009/07/implementing-multiple-precision-arithmetic-part-1.html">earlier post</a> has a cost propertional to \(m \times n\) if the factors have <span class="mthi">m</span> and <span class="mthi">n</span> digits, respectively. Using this cost model, the binary algorithm <em>is</em> actually optimal. This was shown by R. L. Graham, A. C.-C. Yao, and F.-F. Yao in <em>Addition chains with multiplicative cost</em>, Discrete Math., 23 (1978), 115-119 (article available <a href="http://www.math.ucsd.edu/~ronspubs/#78">online</a>).</p>
